{
  "Id": 1,
  "Name": "Mirror the map",
  "UserPrompt": "Spin the player up, disorienting them and slapping them around a bit, then mirror the map, after a bit (or on undo), spin the player back in reverse and unmirror the map.",
  "ExecutionCode": "local hookID = \u0022AIChaos_Mirror_Spin\u0022\n\nif SERVER then\n    util.AddNetworkString(\u0022AIChaos_Mirror_State\u0022)\n    \n    -- Function to apply chaos physics (Slapping player around)\n    local function ApplyChaosPhysics(ply)\n        local duration = 4.0\n        local startTime = CurTime()\n        local nextSlap = CurTime()\n        local physHook = hookID .. \u0022_Phys_\u0022 .. ply:SteamID64()\n        \n        hook.Add(\u0022Think\u0022, physHook, function()\n            if not IsValid(ply) then hook.Remove(\u0022Think\u0022, physHook) return end\n            \n            if CurTime() - startTime \u003E duration then\n                hook.Remove(\u0022Think\u0022, physHook)\n                return\n            end\n            \n            if CurTime() \u003E nextSlap then\n                -- Random violent velocity\n                local vel = Vector(math.random(-500, 500), math.random(-500, 500), math.random(200, 300))\n                ply:SetVelocity(vel)\n                nextSlap = CurTime() \u002B math.Rand(0.5, 1.0)\n            end\n        end)\n    end\n\n    -- Start Phase\n    timer.Simple(0.5, function()\n        for _, ply in ipairs(player.GetAll()) do\n            net.Start(\u0022AIChaos_Mirror_State\u0022)\n            net.WriteBool(true) -- True = Start\n            net.Send(ply)\n            ApplyChaosPhysics(ply)\n        end\n    end)\n    \n    -- Auto-Expire Phase (Trigger spindown after 20s)\n    timer.Create(hookID .. \u0022_Timer\u0022, 20, 1, function()\n        for _, ply in ipairs(player.GetAll()) do\n            net.Start(\u0022AIChaos_Mirror_State\u0022)\n            net.WriteBool(false) -- False = Stop/Spindown\n            net.Send(ply)\n            ApplyChaosPhysics(ply)\n        end\n    end)\nend\n\nRunOnClient([=[\n    local hook_name = \u0022AIChaos_Mirror_Spin\u0022\n    \n    -- State\n    local MirrorActive = false\n    local SpinActive = false\n    local SpinReverse = false\n    local SpinStartTime = 0\n    local SpinDuration = 4.0\n    local SpinPeakTime = 2.0\n    local SpinMaxSpeed = 40\n    local SpinDirection = 1\n    \n    -- Helpers to manage bone flipping\n    local function RemoveFlip(ent)\n        if not IsValid(ent) then return end\n        if ent.AIChaos_FlipCallbackID then\n            ent:RemoveCallback(\u0022BuildBonePositions\u0022, ent.AIChaos_FlipCallbackID)\n        end\n        ent.AIChaos_FlipSetup_Spin = false\n        ent.AIChaos_FlipCallbackID = nil\n    end\n\n    local function SetupFlip(ent)\n        if not IsValid(ent) then return end\n        if ent.AIChaos_FlipSetup_Spin then return end\n        \n        ent.AIChaos_FlipCallbackID = ent:AddCallback(\u0022BuildBonePositions\u0022, function(self, count)\n            local eyePos = EyePos()\n            local eyeAng = EyeAngles()\n            local camMat = Matrix()\n            camMat:SetTranslation(eyePos)\n            camMat:SetAngles(eyeAng)\n            local viewMat = camMat:GetInverse()\n            local scaleMat = Matrix()\n            scaleMat:Scale(Vector(1, -1, 1))\n            local transform = camMat * scaleMat * viewMat\n            \n            for i = 0, count - 1 do\n                local boneMat = self:GetBoneMatrix(i)\n                if boneMat then self:SetBoneMatrix(i, transform * boneMat) end\n            end\n        end)\n        ent.AIChaos_FlipSetup_Spin = true\n    end\n\n    local function CleanupMirror()\n        MirrorActive = false\n        SpinActive = false\n        SpinReverse = false\n        \n        local ply = LocalPlayer()\n        if IsValid(ply) then\n            local vm = ply:GetViewModel()\n            if IsValid(vm) then RemoveFlip(vm) end\n            local hands = ply:GetHands()\n            if IsValid(hands) then RemoveFlip(hands) end\n        end\n        \n        hook.Remove(\u0022CreateMove\u0022, hook_name)\n        hook.Remove(\u0022InputMouseApply\u0022, hook_name)\n        hook.Remove(\u0022PostDrawEffects\u0022, hook_name)\n        hook.Remove(\u0022PreDrawViewModel\u0022, hook_name)\n        hook.Remove(\u0022PostDrawViewModel\u0022, hook_name)\n        hook.Remove(\u0022PreDrawPlayerHands\u0022, hook_name)\n        hook.Remove(\u0022PostDrawPlayerHands\u0022, hook_name)\n        hook.Remove(\u0022DrawPhysgunBeam\u0022, hook_name)\n        hook.Remove(\u0022FireAnimationEvent\u0022, hook_name)\n        hook.Remove(\u0022CalcViewModelView\u0022, hook_name)\n        hook.Remove(\u0022EntityFireBullets\u0022, hook_name)\n    end\n\n    -- Hook Logic\n    local function RegisterHooks()\n        -- Spin \u0026 Control Logic\n        hook.Add(\u0022CreateMove\u0022, hook_name, function(cmd)\n            if SpinActive then\n                local t = CurTime() - SpinStartTime\n                local speed = 0\n                if t \u003C SpinPeakTime then -- Spin Up\n                    local progress = t / SpinPeakTime\n                    speed = SpinMaxSpeed * (progress * progress)\n                elseif t \u003C SpinDuration then -- Spin Down\n                    local progress = (t - SpinPeakTime) / (SpinDuration - SpinPeakTime)\n                    speed = SpinMaxSpeed * (1 - (progress * progress))\n                    \n                    if not SpinReverse then -- Starting: activating\n                        if not MirrorActive then\n                            MirrorActive = true\n                            SpinDirection = -SpinDirection\n                            surface.PlaySound(\u0022buttons/combine_button7.wav\u0022)\n                        end\n                    else -- Stopping: deactivating\n                        if MirrorActive then\n                            MirrorActive = false\n                            SpinDirection = -SpinDirection\n                            surface.PlaySound(\u0022buttons/combine_button7.wav\u0022)\n                            local ply = LocalPlayer()\n                            if IsValid(ply) then\n                                local vm = ply:GetViewModel()\n                                if IsValid(vm) then RemoveFlip(vm) vm:InvalidateBoneCache() vm:SetupBones() end\n                                local hands = ply:GetHands()\n                                if IsValid(hands) then RemoveFlip(hands) hands:InvalidateBoneCache() hands:SetupBones() end\n                            end\n                        end\n                    end\n                else -- End\n                    SpinActive = false\n                    if SpinReverse then CleanupMirror() end\n                end\n                \n                local ang = cmd:GetViewAngles()\n                ang.y = ang.y \u002B (speed * SpinDirection)\n                cmd:SetViewAngles(ang)\n            end\n            \n            if MirrorActive then\n                cmd:SetSideMove(-cmd:GetSideMove())\n                local buttons = cmd:GetButtons()\n                local left = bit.band(buttons, IN_MOVELEFT) == IN_MOVELEFT\n                local right = bit.band(buttons, IN_MOVERIGHT) == IN_MOVERIGHT\n                if left and not right then\n                    buttons = bit.band(buttons, bit.bnot(IN_MOVELEFT))\n                    buttons = bit.bor(buttons, IN_MOVERIGHT)\n                elseif right and not left then\n                    buttons = bit.band(buttons, bit.bnot(IN_MOVERIGHT))\n                    buttons = bit.bor(buttons, IN_MOVELEFT)\n                end\n                cmd:SetButtons(buttons)\n            end\n        end)\n\n        hook.Add(\u0022InputMouseApply\u0022, hook_name, function(cmd, x, y, ang)\n            if not MirrorActive then return end\n            local view_ang = cmd:GetViewAngles()\n            local pitch = GetConVar(\u0022m_pitch\u0022):GetFloat()\n            local yaw = GetConVar(\u0022m_yaw\u0022):GetFloat()\n            view_ang.y = view_ang.y \u002B (x * yaw) -- Invert X logic\n            view_ang.p = view_ang.p \u002B (y * pitch)\n            if view_ang.p \u003E 89 then view_ang.p = 89 end\n            if view_ang.p \u003C -89 then view_ang.p = -89 end\n            cmd:SetViewAngles(view_ang)\n            return true\n        end)\n\n        hook.Add(\u0022PostDrawEffects\u0022, hook_name, function()\n            if not MirrorActive then return end\n            local w, h = ScrW(), ScrH()\n            render.CopyRenderTargetToTexture(render.GetScreenEffectTexture())\n            render.DrawTextureToScreenRect(render.GetScreenEffectTexture(), w, 0, -w, h)\n        end)\n        \n        -- Model Flips\n        hook.Add(\u0022PreDrawViewModel\u0022, hook_name, function(vm, ply, weapon)\n            if not MirrorActive then return end\n            SetupFlip(vm)\n            vm:InvalidateBoneCache()\n            vm:SetupBones()\n            local hands = ply:GetHands()\n            if IsValid(hands) then\n                if hands:GetParent() ~= vm then SetupFlip(hands) else RemoveFlip(hands) hands:InvalidateBoneCache() hands:SetupBones() end\n            end\n            render.CullMode(MATERIAL_CULLMODE_CW)\n        end)\n        hook.Add(\u0022PostDrawViewModel\u0022, hook_name, function() if MirrorActive then render.CullMode(MATERIAL_CULLMODE_CCW) end end)\n        hook.Add(\u0022PreDrawPlayerHands\u0022, hook_name, function() if MirrorActive then render.CullMode(MATERIAL_CULLMODE_CW) end end)\n        hook.Add(\u0022PostDrawPlayerHands\u0022, hook_name, function() if MirrorActive then render.CullMode(MATERIAL_CULLMODE_CCW) end end)\n        \n        hook.Add(\u0022FireAnimationEvent\u0022, hook_name, function(pos, ang, event, options, wep)\n            if not MirrorActive then return end\n            if event == 20 or event == 21 or event == 6001 then\n                if not IsValid(wep) then return end\n                local ply = wep:GetOwner()\n                if IsValid(ply) and ply:IsPlayer() and ply == LocalPlayer() then\n                    local vm = ply:GetViewModel()\n                    if IsValid(vm) then\n                        SetupFlip(vm)\n                        vm:InvalidateBoneCache()\n                        vm:SetupBones()\n                        local attId = 2\n                        if event == 6001 then attId = 1 end\n                        local att = vm:GetAttachment(attId)\n                        if att then\n                            if event == 20 or event == 21 then\n                                local data = EffectData()\n                                data:SetOrigin(att.Pos)\n                                data:SetAngles(att.Ang)\n                                data:SetEntity(wep)\n                                data:SetAttachment(attId)\n                                util.Effect(\u0022ShellEject\u0022, data)\n                            elseif event == 6001 then\n                                local data = EffectData()\n                                data:SetEntity(wep)\n                                data:SetOrigin(att.Pos)\n                                data:SetAngles(att.Ang)\n                                data:SetScale(1)\n                                data:SetAttachment(1)\n                                util.Effect(\u0022MuzzleFlash\u0022, data)\n                            end\n                            return true\n                        end\n                    end\n                end\n            end\n        end)\n\n        hook.Remove(\u0022EntityFireBullets\u0022, hook_name)\n        hook.Remove(\u0022CalcViewModelView\u0022, hook_name)\n\n        hook.Add(\u0022DrawPhysgunBeam\u0022, hook_name, function(ply)\n            if MirrorActive and ply == LocalPlayer() then\n                local vm = ply:GetViewModel()\n                if IsValid(vm) then vm:InvalidateBoneCache() vm:SetupBones() end\n            end\n        end)\n    end\n\n    local function StartEffect()\n        CleanupMirror()\n        RegisterHooks()\n        MirrorActive = false\n        SpinActive = true\n        SpinReverse = false\n        SpinStartTime = CurTime()\n        SpinDirection = math.random(0, 1) == 1 and 1 or -1\n        surface.PlaySound(\u0022ambient/machines/spinup.wav\u0022)\n    end\n\n    local function StopEffect()\n        if MirrorActive then\n            SpinActive = true\n            SpinReverse = true\n            SpinStartTime = CurTime()\n            SpinDirection = math.random(0, 1) == 1 and 1 or -1\n            surface.PlaySound(\u0022ambient/machines/spinup.wav\u0022)\n        else\n            CleanupMirror()\n        end\n    end\n\n    net.Receive(\u0022AIChaos_Mirror_State\u0022, function()\n        local start = net.ReadBool()\n        if start then StartEffect() else StopEffect() end\n    end)\n]=])",
  "UndoCode": "local hookID = \u0022AIChaos_Mirror_Spin\u0022\n\nif SERVER then\n    -- Remove the start/timer hooks\n    timer.Remove(hookID .. \u0022_Timer\u0022) \n    \n    -- Function to apply chaos physics (copied for undo context)\n    local function ApplyUndoChaos(ply)\n        local duration = 4.0\n        local startTime = CurTime()\n        local nextSlap = CurTime()\n        local physHook = hookID .. \u0022_Phys_Undo_\u0022 .. ply:SteamID64()\n        \n        hook.Add(\u0022Think\u0022, physHook, function()\n            if not IsValid(ply) then hook.Remove(\u0022Think\u0022, physHook) return end\n            if CurTime() - startTime \u003E duration then hook.Remove(\u0022Think\u0022, physHook) return end\n            if CurTime() \u003E nextSlap then\n                local vel = Vector(math.random(-500, 500), math.random(-500, 500), math.random(200, 300))\n                ply:SetVelocity(vel)\n                nextSlap = CurTime() \u002B math.Rand(0.5, 1.0)\n            end\n        end)\n    end\n\n    -- Tell clients to Spindown\n    for _, ply in ipairs(player.GetAll()) do\n        net.Start(\u0022AIChaos_Mirror_State\u0022)\n        net.WriteBool(false) -- False = Stop sequence\n        net.Send(ply)\n        ApplyUndoChaos(ply)\n    end\nend",
  "Category": "Annoyances",
  "Description": null,
  "SavedAt": "2025-12-16T03:11:01.2676113Z",
  "OriginalCommandId": 250,
  "IsBuiltIn": true
}
@page "/"
@rendermode InteractiveServer
@inject AccountService AccountService
@inject CommandQueueService CommandQueue
@inject AiCodeGeneratorService CodeGenerator
@inject PromptModerationService ModerationService
@inject CodeModerationService CodeModerationService
@inject AgenticGameService AgenticService
@inject SettingsService SettingsService
@inject TestClientService TestClientService
@inject RefundService RefundService
@inject RedoService RedoService
@inject YouTubeService YouTubeService
@inject FavouritesService FavouritesService
@inject IJSRuntime JS
@using AIChaos.Brain.Components.Layout
@using AIChaos.Brain.Components.Shared
@using AIChaos.Brain.Helpers
@using AIChaos.Brain.Models
@implements IDisposable

<PageTitle>Chaos - Viewer Control</PageTitle>
<SectionContent SectionId="PageSections.Title">üéÆ CHAOS</SectionContent>
<SectionContent SectionId="PageSections.Subtitle">Control the streamer's game!</SectionContent>

@if (!YouTubeService.IsListening && SettingsService.Settings.General.StreamMode)
{
    <div class="card" style="text-align: center; padding: 60px 20px;">
        <h2 style="font-size: 32px; margin-bottom: 20px;">üì∫ Stream Offline</h2>
        <p style="color: var(--text-dim); font-size: 18px;">Come back soon!</p>
        <p style="color: var(--text-dim); font-size: 14px; margin-top: 10px;">The stream is not currently active.</p>
    </div>
}
else
{
<div class="card">
    <h2>Send Your Idea</h2>
    @if (SettingsService.Settings.General.StreamMode)
    {
        <p style="color: var(--text-dim); font-size: 14px; margin-bottom: 15px;">Each dollar gets you one Idea. Be creative - funny, helpful, or chaotic!</p>
    }
    else
    {
        <p style="color: var(--text-dim); font-size: 14px; margin-bottom: 15px;">Be creative - funny, helpful, or chaotic!</p>
    }
    <div class="form-group">
        <textarea @bind="promptInput" placeholder="@GetPlaceholder()" disabled="@(currentAccount == null)"></textarea>
    </div>

    <div class="form-group" style="margin-bottom: 15px;">
        <button @onclick="() => showFavouritesModal = true" class="btn-secondary" style="margin-bottom: 10px; font-size: 14px;">
            ‚≠ê Browse Example Prompts
        </button>
        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
            <input type="checkbox" @bind="interactiveMode" style="width: 18px; height: 18px;">
            <span>üîÑ Interactive Mode</span>
            <span style="color: var(--text-dim); font-size: 12px;">(AI can search models, test code, and fix errors automatically, This can be up to 5x slower!!)</span>
        </label>
    </div>

    <button @onclick="SubmitCommand" disabled="@(IsButtonDisabled())">
        @if (isSubmitting)
        {
            <text>‚è≥ SENDING...</text>
        }
        else if (currentAccount == null)
        {
            <text>üîí LOGIN TO PLAY</text>
        }
        else if (SettingsService.Settings.General.StreamMode && currentAccount.CreditBalance < Constants.CommandCost)
        {
            <text>üí∏ You'll need to donate again to send another</text>
        }
        else
        {
            <text>‚ö° SEND CHAOS</text>
        }
    </button>
    
    @if (!string.IsNullOrEmpty(statusMessage))
    {
        <div style="margin-top: 15px;">
            <div class="alert alert-@statusType">@statusMessage</div>
        </div>
    }
    
    @if (activeInteractiveSession != null)
    {
        <div class="interactive-status" style="margin-top: 15px; padding: 15px; background: rgba(0,255,0,0.1); border: 1px solid var(--success); border-radius: 8px; position: relative;">
            <button @onclick="DismissInteractiveStatus" style="position: absolute; top: 10px; right: 10px; background: transparent; border: 1px solid var(--text-dim); color: var(--text-dim); padding: 2px 8px; border-radius: 4px; cursor: pointer; font-size: 12px;">‚úï Dismiss</button>
            <h4 style="margin: 0 0 10px 0;">
                üîÑ Interactive Session 
                <span style="font-size: 12px;">
                    @if (activeInteractiveSession.IsComplete)
                    {
                        @if (activeInteractiveSession.Status == "complete")
                        {
                            <span style="color: var(--success);">‚úì Complete</span>
                        }
                        else
                        {
                            <span style="color: var(--error);">‚úó Failed</span>
                        }
                    }
                    else
                    {
                        <span style="color: var(--warning);">‚è≥ In Progress</span>
                    }
                </span>
            </h4>
            <div style="margin: 5px 0;">
                <strong>Phase:</strong> <span class="phase-badge" style="background: rgba(255,255,255,0.1); padding: 2px 8px; border-radius: 4px; font-size: 12px;">@activeInteractiveSession.CurrentPhase</span>
            </div>
            <div style="margin: 5px 0;">
                <strong>Iteration:</strong> @activeInteractiveSession.Iteration / 5
            </div>
            @if (activeInteractiveSession.Steps.Any())
            {
                <div style="margin-top: 10px;">
                    @foreach (var step in activeInteractiveSession.Steps)
                    {
                        <div class="interactive-step" style="margin: 5px 0; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px; font-size: 12px;">
                            <div><strong>Step @step.StepNumber:</strong> @step.Phase</div>
                            @if (!string.IsNullOrEmpty(step.AiThinking))
                            {
                                <div style="color: var(--text-dim);">üí≠ @(step.AiThinking.Length > 100 ? step.AiThinking.Substring(0, 100) + "..." : step.AiThinking)</div>
                            }
                            @if (step.Success == true)
                            {
                                <span style="color: var(--success);">‚úì Success</span>
                            }
                            else if (step.Success == false)
                            {
                                <span style="color: var(--error);">‚úó @(step.Error ?? "Failed")</span>
                            }
                        </div>
                    }
                </div>
            }
        </div>
    }
</div>

<div class="card">
    <h2>üìã Your Recent Ideas</h2>
    <div id="recentCommands">
        @if (recentCommands == null || !recentCommands.Any())
        {
            <div class="empty-state">@(currentAccount == null ? "Sign in to see your history..." : "No Ideas yet.")</div>
        }
        else
        {
            @foreach (var cmd in recentCommands)
            {
                <div class="history-item">
                    <div style="flex: 1;">
                        <div class="history-time">@cmd.Timestamp.ToLocalTime().ToString("HH:mm:ss")</div>
                        <div class="history-prompt">@cmd.UserPrompt</div>
                        <div class="history-status status-@CommandStatusHelper.GetStatusClass(cmd.Status)">@CommandStatusHelper.GetStatusText(cmd.Status)</div>
                    </div>
                    <div class="history-actions">
                        <button @onclick="() => RepeatCommand(cmd.Id)" class="btn-info btn-small" title="Replay the same code without changes">‚ñ∂Ô∏è Replay</button>
                        <button @onclick="() => OpenRedoModal(cmd.Id)" class="btn-success btn-small" title="Describe what went wrong and AI will fix it">üîß Fix</button>
                        <button @onclick="() => UndoCommand(cmd.Id)" class="btn-warning btn-small" title="Undo">‚Ü© Undo</button>
                        <button @onclick="() => OpenRefundModal(cmd.Id)" class="btn-danger btn-small" title="Report Problem" style="font-size: 11px;">‚ö†Ô∏è Report</button>
                    </div>
                </div>
            }
        }
    </div>
</div>

<!-- Refund Modal -->
<Modal @bind-IsOpen="showRefundModal">
    <h3>Report a Problem</h3>
    <p>Why are you requesting a refund for this command?</p>
    <div style="display: flex; flex-direction: column; gap: 10px; margin: 15px 0;">
        <label style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; cursor: pointer;">
            <input type="radio" name="refundReason" value="My request didn't work" checked="@(selectedRefundReason == "My request didn't work")" @onchange="@(() => selectedRefundReason = "My request didn't work")">
            <span>My request didn't work / AI failed</span>
        </label>
        <label style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; cursor: pointer;">
            <input type="radio" name="refundReason" value="The streamer didn't see my request" checked="@(selectedRefundReason == "The streamer didn't see my request")" @onchange="@(() => selectedRefundReason = "The streamer didn't see my request")">
            <span>The streamer didn't see my request</span>
        </label>
        <label style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; cursor: pointer;">
            <input type="radio" name="refundReason" value="I changed my mind" checked="@(selectedRefundReason == "I changed my mind")" @onchange="@(() => selectedRefundReason = "I changed my mind")">
            <span>I changed my mind</span>
        </label>
        <label style="display: flex; align-items: center; gap: 10px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 5px; cursor: pointer;">
            <input type="radio" name="refundReason" value="It wasn't funny" checked="@(selectedRefundReason == "It wasn't funny")" @onchange="@(() => selectedRefundReason = "It wasn't funny")">
            <span>It wasn't funny</span>
        </label>
    </div>
    <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button @onclick="() => showRefundModal = false" class="btn-secondary">Cancel</button>
        <button @onclick="SubmitRefund" class="btn-primary">Submit Report</button>
    </div>
</Modal>
}

<!-- Fix with Feedback Modal -->
@if (showRedoModal)
{
<Modal @bind-IsOpen="showRedoModal">
    <h3>üîß Fix with AI</h3>
    @{
        var isFree = currentAccount != null && RedoService.IsNextRedoFree(currentAccount.Id);
        var cost = currentAccount != null ? RedoService.GetRedoCost(currentAccount.Id) : Constants.Redo.RedoCost;
    }
    <p style="margin-top: 10px;">Explain briefly what stopped your request from working and we will try to fix it:</p>
    <div style="margin: 15px 0;">
        <textarea 
            @bind="redoFeedback" 
            placeholder="E.g., 'The effect only lasted 2 seconds instead of the full duration' or 'Nothing happened when I submitted'"
            style="width: 100%; min-height: 100px; padding: 10px; border-radius: 5px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: var(--text-main); resize: vertical;"
            disabled="@isRedoSubmitting">
        </textarea>
    </div>
    <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button @onclick="() => showRedoModal = false" class="btn-secondary" disabled="@isRedoSubmitting">Cancel</button>
        <button @onclick="SubmitRedo" class="btn-success" disabled="@(isRedoSubmitting || string.IsNullOrWhiteSpace(redoFeedback))">
            @if (isRedoSubmitting)
            {
                <span>Fixing...</span>
            }
            else
            {
                <span>üîß Fix</span>
            }
        </button>
    </div>
</Modal>
}

<!-- Favourites/Example Prompts Modal -->
@if (showFavouritesModal)
{
<Modal @bind-IsOpen="showFavouritesModal">
    <h3>‚≠ê Example Prompts</h3>
    <p style="color: var(--text-dim); margin-bottom: 15px;">Browse and execute pre-made chaos prompts!</p>
    
    @{
        var favourites = FavouritesService.GetAllFavourites();
        var savedPayloads = CommandQueue.GetSavedPayloads();
        var categories = FavouritesService.GetCategories();
        var hasSavedPayloads = savedPayloads.Any();
        var hasFavourites = favourites.Any();
        var hasAny = hasFavourites || hasSavedPayloads;
    }
    
    @if (!hasAny)
    {
        <div style="text-align: center; padding: 30px; color: var(--text-dim);">
            <p>No example prompts available yet.</p>
            <p style="font-size: 12px;">Admins can save prompts from command history using the üíæ button.</p>
        </div>
    }
    else
    {
        <!-- Category Filter (only show if we have favourites with categories) -->
        @if (categories.Count > 1 || hasSavedPayloads)
        {
            <div style="margin-bottom: 15px; display: flex; gap: 8px; flex-wrap: wrap;">
                <button @onclick="() => selectedFavouriteCategory = null" 
                        class="@(selectedFavouriteCategory == null ? "btn-primary" : "btn-secondary")"
                        style="font-size: 12px; padding: 5px 10px;">
                    All
                </button>
                @if (hasSavedPayloads)
                {
                    <button @onclick='() => selectedFavouriteCategory = "Saved"' 
                            class="@(selectedFavouriteCategory == "Saved" ? "btn-primary" : "btn-secondary")"
                            style="font-size: 12px; padding: 5px 10px;">
                        üíæ Saved (@savedPayloads.Count)
                    </button>
                }
                @foreach (var cat in categories)
                {
                    <button @onclick="() => selectedFavouriteCategory = cat" 
                            class="@(selectedFavouriteCategory == cat ? "btn-primary" : "btn-secondary")"
                            style="font-size: 12px; padding: 5px 10px;">
                        @cat
                    </button>
                }
            </div>
        }
        
        <!-- Prompts List -->
        <div style="max-height: 400px; overflow-y: auto;">
            <!-- Saved Payloads -->
            @if (selectedFavouriteCategory == null || selectedFavouriteCategory == "Saved")
            {
                @foreach (var payload in savedPayloads)
                {
                    <div class="favourite-item" style="padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <div style="flex: 1;">
                                <div style="font-weight: bold; color: var(--text-main);">@payload.Name</div>
                                <div style="color: var(--text-dim); font-size: 12px; margin-top: 4px;">@payload.UserPrompt</div>
                                <div style="font-size: 10px; color: var(--text-dim); margin-top: 4px;">
                                    <span style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px;">üíæ Saved</span>
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px; margin-left: 10px;">
                                <button @onclick="() => UseSavedPayloadAsPrompt(payload)" class="btn-secondary btn-small" title="Copy to prompt box">
                                    ‚úèÔ∏è Modify
                                </button>
                                <button @onclick="() => ExecuteSavedPayload(payload)" class="btn-success btn-small" title="Execute immediately">
                                    ‚ö° Run
                                </button>
                            </div>
                        </div>
                    </div>
                }
            }
            
            <!-- Favourites -->
            @if (selectedFavouriteCategory != "Saved")
            {
                @foreach (var fav in favourites.Where(f => selectedFavouriteCategory == null || f.Category == selectedFavouriteCategory))
                {
                    <div class="favourite-item" style="padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <div style="flex: 1;">
                                <div style="font-weight: bold; color: var(--text-main);">@fav.Name</div>
                                <div style="color: var(--text-dim); font-size: 12px; margin-top: 4px;">@fav.UserPrompt</div>
                                @if (!string.IsNullOrEmpty(fav.Description))
                                {
                                    <div style="color: var(--text-dim); font-size: 11px; margin-top: 4px; font-style: italic;">@fav.Description</div>
                                }
                                <div style="font-size: 10px; color: var(--text-dim); margin-top: 4px;">
                                    <span style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px;">@fav.Category</span>
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px; margin-left: 10px;">
                                <button @onclick="() => UseFavouriteAsPrompt(fav)" class="btn-secondary btn-small" title="Copy to prompt box">
                                    ‚úèÔ∏è Modify
                                </button>
                                <button @onclick="() => ExecuteFavourite(fav.Id)" class="btn-success btn-small" title="Execute immediately">
                                    ‚ö° Run
                                </button>
                            </div>
                        </div>
                    </div>
                }
            }
        </div>
    }
    
    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
        <button @onclick="() => showFavouritesModal = false" class="btn-secondary">Close</button>
    </div>
</Modal>
}

@* Login/Register Modal *@

<style>
    .radio-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin: 15px 0;
    }

    .radio-option {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 5px;
        cursor: pointer;
    }

    .radio-option:hover {
        background: rgba(255, 255, 255, 0.1);
    }

    .radio-option input[type="radio"] {
        cursor: pointer;
    }

    .history-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        margin-bottom: 10px;
    }

    .history-time {
        color: var(--text-dim);
        font-size: 12px;
    }

    .history-prompt {
        color: var(--text);
        margin: 5px 0;
    }

    .history-status {
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 11px;
        display: inline-block;
    }

    .status-pending { background: #888; }
    .status-pendingmoderation { background: #ff9800; color: #000; }
    .status-queued { background: #f0ad4e; }
    .status-executed { background: #5cb85c; }
    .status-undone { background: #5bc0de; }
    .status-failed { background: #d9534f; }

    .interactive-status {
        padding: 15px;
        border-radius: 8px;
        margin-top: 15px;
        position: relative;
    }

    .interactive-status h4 {
        margin: 0 0 10px 0;
    }

    .interactive-status .phase-badge {
        background: rgba(255,255,255,0.1);
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 12px;
    }

    .interactive-step {
        margin: 5px 0;
        padding: 8px;
        background: rgba(0,0,0,0.2);
        border-radius: 4px;
        font-size: 12px;
    }
    
    .favourite-item:hover {
        background: rgba(255,255,255,0.08) !important;
    }
</style>

@code {
    [CascadingParameter]
    private Account? currentAccount { get; set; }
    
    private string promptInput = "";
    private bool interactiveMode = false;
    private List<CommandEntry>? recentCommands;
    private string statusMessage = "";
    private string statusType = "info";
    private bool isSubmitting = false;
    private InteractiveSessionResponse? activeInteractiveSession = null;
    private System.Threading.Timer? interactivePollingTimer = null;
    private bool showRefundModal = false;
    private int selectedCommandIdForRefund = 0;
    private string selectedRefundReason = "";
    private bool showRedoModal = false;
    private int selectedCommandIdForRedo = 0;
    private string redoFeedback = "";
    private bool isRedoSubmitting = false;
    private bool _isInitialized = false;
    private System.Threading.Timer? streamStateRefreshTimer = null;
    private bool showFavouritesModal = false;
    private string? selectedFavouriteCategory = null;
    private string? _modifyReferenceCode = null;  // Store original code when modifying a favourite
    private string? _modifyReferenceUndoCode = null;

    protected override async Task OnParametersSetAsync()
    {
        // Only load history if we have an account and component is initialized
        if (currentAccount != null && _isInitialized)
        {
            await LoadHistory();
        }
    }

    protected override void OnInitialized()
    {
        _isInitialized = true;
        
        // Subscribe to history changes
        CommandQueue.HistoryChanged += OnHistoryChanged;
        
        // Start stream state refresh timer
        StartStreamStateRefresh();
    }

    private async void OnHistoryChanged(object? sender, EventArgs e)
    {
        // Reload history when it changes
        await InvokeAsync(async () =>
        {
            try
            {
                await LoadHistory();
                StateHasChanged();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in OnHistoryChanged: {ex.Message}");
            }
        });
    }
    
    private void StartStreamStateRefresh()
    {
        // Refresh UI every 2 seconds to check stream state
        streamStateRefreshTimer = new System.Threading.Timer(async _ =>
        {
            try
            {
                await InvokeAsync(() =>
                {
                    if (!_isInitialized)
                        return;
                    
                    StateHasChanged();
                });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error refreshing stream state: {ex.Message}");
            }
        }, null, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(2));
    }

    public void Dispose()
    {
        // Unsubscribe from events
        CommandQueue.HistoryChanged -= OnHistoryChanged;
        
        // Stop interactive polling if active
        interactivePollingTimer?.Dispose();
        
        // Stop stream state refresh
        streamStateRefreshTimer?.Dispose();
        
        _isInitialized = false;
    }

    private async Task SubmitCommand()
    {
        if (currentAccount == null || string.IsNullOrWhiteSpace(promptInput) || isSubmitting)
            return;
        
        // Check for banned concepts
        var (isBanned, isHardBan, category, reason) = ModerationService.CheckBannedConcepts(promptInput);
        if (isBanned)
        {
            if (isHardBan)
            {
                if (!string.IsNullOrEmpty(reason) && !reason.StartsWith("Contains banned concept:"))
                {
                    ShowStatus($"‚õî {reason}", "error");
                }
                else
                {
                    ShowStatus($"‚õî Request blocked: '{category}' is not allowed.", "error");
                }
            }
            else
            {
                // Soft ban: "Be funnier"
                ShowStatus("üòê Be funnier.", "warning");
            }
            return;
        }
        
        isSubmitting = true;
        StateHasChanged();
        
        try
        {
            var isSingleUserMode = !SettingsService.Settings.General.StreamMode;
            
            // Check balance FIRST (before starting interactive session) - skip in single user mode
            if (!isSingleUserMode && currentAccount.CreditBalance < Constants.CommandCost)
            {
                ShowStatus($"Insufficient credits. You need ${Constants.CommandCost:F2}", "error");
                isSubmitting = false;
                return;
            }
            
            // If interactive mode is enabled, use the interactive endpoint
            if (interactiveMode)
            {
                await SubmitInteractiveCommand();
                return;
            }
            
            // Regular command submission
            // Use AccountService to handle the full submission flow
            // Capture reference code before it gets cleared
            var refCode = _modifyReferenceCode;
            var refUndoCode = _modifyReferenceUndoCode;
            
            var (success, message, commandId, newBalance) = await AccountService.SubmitChaosCommandAsync(
                currentAccount.Id,
                promptInput,
                codeGenerator: async (prompt) => await CodeGenerator.GenerateCodeAsync(
                    prompt, 
                    referenceCode: refCode, 
                    referenceUndoCode: refUndoCode),
                needsModeration: ModerationService.NeedsModeration,
                extractImageUrls: ModerationService.ExtractContentUrls,
                addPendingImage: (url, prompt, source, author, userId, cmdId) => 
                    ModerationService.AddPendingPrompt(url, prompt, source, author, userId, cmdId),
                addPendingCode: (prompt, execCode, undoCode, reason, source, author, userId, cmdId) =>
                    CodeModerationService.AddPendingCode(prompt, execCode, undoCode, reason, source, author, userId, cmdId),
                addCommandWithStatus: (prompt, execCode, undoCode, source, author, imgCtx, userId, aiResp, status, queue) =>
                    CommandQueue.AddCommandWithStatus(prompt, execCode, undoCode, source, author, imgCtx, userId, aiResp, status, queue),
                isPrivateDiscordMode: SettingsService.Settings.Safety.PrivateDiscordMode,
                isTestClientModeEnabled: TestClientService.IsEnabled,
                isSingleUserMode: isSingleUserMode
            );

            // Update balance in UI
            currentAccount.CreditBalance = newBalance;

            if (success)
            {
                promptInput = "";
                // Clear reference code after successful submission
                _modifyReferenceCode = null;
                _modifyReferenceUndoCode = null;
                await LoadHistory();
            }

            ShowStatus(message, success ? "success" : "error");
        }
        catch (Exception ex)
        {
            ShowStatus("Error submitting command", "error");
            Console.WriteLine($"Submit failed: {ex.Message}");
        }
        finally
        {
            isSubmitting = false;
            StateHasChanged();
        }
    }

    private async Task SubmitInteractiveCommand()
    {
        try
        {
            var isSingleUserMode = !SettingsService.Settings.General.StreamMode;
            
            // Use AccountService to handle credit deduction and moderation checks
            var (success, message, commandId, newBalance) = await AccountService.SubmitInteractiveCommandAsync(
                currentAccount!.Id,
                promptInput,
                needsModeration: ModerationService.NeedsModeration,
                extractImageUrls: ModerationService.ExtractContentUrls,
                addPendingImage: (url, prompt, source, author, userId, cmdId) => 
                    ModerationService.AddPendingPrompt(url, prompt, source, author, userId, cmdId),
                addCommandWithStatus: (prompt, execCode, undoCode, source, author, imgCtx, userId, aiResp, status, queue) =>
                    CommandQueue.AddCommandWithStatus(prompt, execCode, undoCode, source, author, imgCtx, userId, aiResp, status, queue),
                isPrivateDiscordMode: SettingsService.Settings.Safety.PrivateDiscordMode,
                isSingleUserMode: isSingleUserMode
            );
            
            // Update balance in UI
            currentAccount.CreditBalance = newBalance;
            
            if (!success)
            {
                // If it failed (moderation, rate limit, etc), show the error
                ShowStatus(message, "error");
                isSubmitting = false;
                return;
            }
            
            // If we got a command ID, it means it's pending moderation
            // Check for various moderation-related keywords in the message
            if (commandId.HasValue && (message.Contains("moderation") || message.Contains("moderator") || message.Contains("approval")))
            {
                ShowStatus(message, "info");
                promptInput = "";
                await LoadHistory();
                isSubmitting = false;
                return;
            }
            
            // Start the interactive session directly using AgenticService
            var session = await AgenticService.CreateSessionAsync(new AgentSessionRequest
            {
                Prompt = promptInput,
                Source = "web",
                Author = currentAccount!.DisplayName,
                UserId = currentAccount!.Id,
                MaxIterations = 5,
                UseTestClient = false
            });
            
            if (session != null)
            {
                // Map AgentSession to InteractiveSessionResponse for UI
                activeInteractiveSession = new InteractiveSessionResponse
                {
                    Status = session.IsComplete ? (session.WasSuccessful ? "complete" : "failed") : "in_progress",
                    SessionId = session.Id,
                    Iteration = session.CurrentIteration,
                    CurrentPhase = session.CurrentPhase.ToString(),
                    IsComplete = session.IsComplete,
                    Steps = session.Steps.Select(s => new InteractionStep
                    {
                        StepNumber = s.StepNumber,
                        Phase = s.Phase,
                        Code = s.Code,
                        Success = s.Success,
                        Error = s.Error,
                        ResultData = s.ResultData,
                        AiThinking = s.AiThinking,
                        Timestamp = s.Timestamp
                    }).ToList()
                };
                
                promptInput = "";
                ShowStatus("üîÑ Interactive session started", "info");
                
                // Start polling for updates
                StartInteractivePolling(session.Id);
            }
            else
            {
                ShowStatus("Failed to start interactive session", "error");
                isSubmitting = false;
            }
        }
        catch (Exception ex)
        {
            ShowStatus($"Error: {ex.Message}", "error");
            Console.WriteLine($"Interactive mode error: {ex}");
            isSubmitting = false;
        }
    }

    private void StartInteractivePolling(int sessionId)
    {
        interactivePollingTimer = new System.Threading.Timer(async _ =>
        {
            await InvokeAsync(async () =>
            {
                try
                {
                    // Get session directly from AgenticService instead of HTTP call
                    var session = AgenticService.GetSession(sessionId);
                    
                    if (session != null)
                    {
                        // Map to UI model
                        activeInteractiveSession = new InteractiveSessionResponse
                        {
                            Status = session.IsComplete ? (session.WasSuccessful ? "complete" : "failed") : "in_progress",
                            SessionId = session.Id,
                            Iteration = session.CurrentIteration,
                            CurrentPhase = session.CurrentPhase.ToString(),
                            IsComplete = session.IsComplete,
                            Steps = session.Steps.Select(s => new InteractionStep
                            {
                                StepNumber = s.StepNumber,
                                Phase = s.Phase,
                                Code = s.Code,
                                Success = s.Success,
                                Error = s.Error,
                                ResultData = s.ResultData,
                                AiThinking = s.AiThinking,
                                Timestamp = s.Timestamp
                            }).ToList()
                        };
                        
                        StateHasChanged();
                        
                        if (session.IsComplete)
                        {
                            // Session finished
                            StopInteractivePolling();
                            isSubmitting = false;
                            
                            if (session.WasSuccessful)
                            {
                                ShowStatus("‚úì Interactive session completed successfully!", "success");
                            }
                            else
                            {
                                ShowStatus("‚úó Interactive session failed", "error");
                            }
                            
                            await LoadHistory();
                            
                            // Update balance
                            var updatedAccount = AccountService.GetAccountById(currentAccount!.Id);
                            if (updatedAccount != null)
                            {
                                currentAccount.CreditBalance = updatedAccount.CreditBalance;
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Interactive polling error: {ex.Message}");
                }
            });
        }, null, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(2));
    }

    private void StopInteractivePolling()
    {
        interactivePollingTimer?.Dispose();
        interactivePollingTimer = null;
    }

    private Task LoadHistory()
    {
        if (currentAccount == null)
            return Task.CompletedTask;
        
        try
        {
            var history = CommandQueue.GetHistoryForUser(currentAccount.Id);
            recentCommands = history.TakeLast(10).Reverse().ToList();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Load history failed: {ex.Message}");
        }
        
        return Task.CompletedTask;
    }

    private Task UndoCommand(int commandId)
    {
        try
        {
            var success = CommandQueue.UndoCommand(commandId);
            ShowStatus(success ? "Undo queued" : "Failed to undo command", success ? "success" : "error");
        }
        catch (Exception ex)
        {
            ShowStatus("Error undoing command", "error");
            Console.WriteLine($"Undo failed: {ex.Message}");
        }
        
        return Task.CompletedTask;
    }

    private async Task RepeatCommand(int commandId)
    {
        try
        {
            if (currentAccount == null)
            {
                ShowStatus("Please sign in to repeat commands", "error");
                return;
            }

            var command = CommandQueue.GetHistory().FirstOrDefault(c => c.Id == commandId);
            if (command == null)
            {
                ShowStatus("Command not found", "error");
                return;
            }

            var isSingleUserMode = !SettingsService.Settings.General.StreamMode;

            // Check if command contains content that needs moderation
            var contentUrls = ModerationService.ExtractContentUrls(command.UserPrompt);
            var needsModeration = contentUrls.Count > 0;
            
            // Check and deduct credits (for both filtered and non-filtered commands in Stream Mode)
            if (!isSingleUserMode)
            {
                // Early check to provide detailed error message to user
                if (currentAccount.CreditBalance < Constants.CommandCost)
                {
                    ShowStatus($"Insufficient credits. You have ${currentAccount.CreditBalance:F2}, but need ${Constants.CommandCost:F2}", "error");
                    return;
                }

                if (!AccountService.DeductCredits(currentAccount.Id, Constants.CommandCost))
                {
                    // Refresh to get current balance for error message
                    var currentBalance = AccountService.GetAccountById(currentAccount.Id)?.CreditBalance ?? currentAccount.CreditBalance;
                    ShowStatus($"Insufficient credits. You have ${currentBalance:F2}, but need ${Constants.CommandCost:F2}", "error");
                    return;
                }

                // Refresh the account from the service
                var updatedAccount = AccountService.GetAccountById(currentAccount.Id);
                if (updatedAccount != null)
                {
                    currentAccount = updatedAccount;
                }
            }
            
            if (needsModeration)
            {
                // Command contains content - must go through moderation flow
                // Create placeholder command with PendingModeration status
                var placeholderCommand = CommandQueue.AddCommandWithStatus(
                    userPrompt: command.UserPrompt,
                    executionCode: "", // Will be set after approval
                    undoCode: "", // Will be set after approval
                    source: "history_repeat",
                    author: currentAccount.DisplayName,
                    imageContext: null, // Will be set after approval
                    userId: currentAccount.Id,
                    aiResponse: "‚è≥ Waiting for content moderation approval...",
                    status: CommandStatus.PendingModeration,
                    queueForExecution: false); // Don't queue yet

                // Queue content for moderation with link to new command
                foreach (var url in contentUrls)
                {
                    ModerationService.AddPendingPrompt(url, command.UserPrompt, "history_repeat", currentAccount.DisplayName, currentAccount.Id, placeholderCommand.Id);
                }

                var message = isSingleUserMode 
                    ? $"Command repeated with {contentUrls.Count} content URL(s) queued for moderation"
                    : $"Command repeated with {contentUrls.Count} content URL(s) queued for moderation. New balance: ${currentAccount.CreditBalance:F2}";
                ShowStatus(message, "info");
                await LoadHistory();
                return;
            }

            // No content requiring moderation - use original fast path
            CommandQueue.AddCommand(
                userPrompt: command.UserPrompt,
                executionCode: command.ExecutionCode,
                undoCode: command.UndoCode,
                source: "history_repeat",
                author: currentAccount.DisplayName,
                imageContext: command.ImageContext,
                userId: currentAccount.Id,
                aiResponse: null
            );

            var successMessage = isSingleUserMode 
                ? "Command repeated and queued" 
                : $"Command repeated and queued. New balance: ${currentAccount.CreditBalance:F2}";
            ShowStatus(successMessage, "success");
            await LoadHistory();
        }
        catch (Exception ex)
        {
            ShowStatus("Error repeating command", "error");
            Console.WriteLine($"Repeat failed: {ex.Message}");
        }
    }

    private void OpenRefundModal(int commandId)
    {
        selectedCommandIdForRefund = commandId;
        selectedRefundReason = "";
        showRefundModal = true;
    }

    private async Task SubmitRefund()
    {
        if (string.IsNullOrEmpty(selectedRefundReason))
        {
            ShowStatus("Please select a reason", "error");
            return;
        }

        if (currentAccount == null)
        {
            ShowStatus("You must be logged in to request a refund", "error");
            return;
        }

        try
        {
            // Reasons that trigger a real refund request (others show fake "Submitted" success)
            var realRefundReasons = new[] { "My request didn't work", "The streamer didn't see my request" };
            var isRealReason = realRefundReasons.Any(r => r.Equals(selectedRefundReason, StringComparison.OrdinalIgnoreCase));
            
            if (!isRealReason)
            {
                // Fake submission - show success but don't create a real request
                ShowStatus("Your report has been submitted. Thank you for your feedback!", "success");
                showRefundModal = false;
                return;
            }
            
            // Get the command to find the prompt for audit purposes
            var command = CommandQueue.GetCommand(selectedCommandIdForRefund);
            if (command == null)
            {
                ShowStatus("Command not found. Cannot process refund request.", "error");
                return;
            }
            
            // Create real refund request using service directly
            var refundRequest = RefundService.CreateRequest(
                currentAccount.Id,
                currentAccount.DisplayName,
                selectedCommandIdForRefund,
                command.UserPrompt,
                selectedRefundReason,
                Constants.CommandCost
            );
            
            if (refundRequest == null)
            {
                ShowStatus("Could not create refund request. This command may have already been refunded.", "error");
                return;
            }
            
            ShowStatus("Your refund request has been submitted for review.", "success");
            showRefundModal = false;
        }
        catch (Exception ex)
        {
            ShowStatus("Error submitting report", "error");
            Console.WriteLine($"Refund request failed: {ex.Message}");
        }
    }

    private void OpenRedoModal(int commandId)
    {
        selectedCommandIdForRedo = commandId;
        redoFeedback = "";
        isRedoSubmitting = false;
        showRedoModal = true;
    }

    private async Task SubmitRedo()
    {
        if (string.IsNullOrWhiteSpace(redoFeedback))
        {
            ShowStatus("Please provide feedback about what went wrong", "error");
            return;
        }

        if (currentAccount == null)
        {
            ShowStatus("You must be logged in to redo a command", "error");
            return;
        }

        isRedoSubmitting = true;
        StateHasChanged();

        try
        {
            var isSingleUserMode = !SettingsService.Settings.General.StreamMode;
            var response = await RedoService.RequestRedoAsync(
                currentAccount.Id,
                selectedCommandIdForRedo,
                redoFeedback,
                isSingleUserMode
            );

            if (response.Status == "success")
            {
                ShowStatus(response.Message ?? "Fix submitted successfully!", "success");
                showRedoModal = false;
                
                // Refresh account to show updated balance
                var updatedAccount = AccountService.GetAccountById(currentAccount.Id);
                if (updatedAccount != null)
                {
                    currentAccount = updatedAccount;
                }
                
                await LoadHistory();
            }
            else
            {
                ShowStatus(response.Message ?? "Failed to submit fix", "error");
            }
        }
        catch (Exception ex)
        {
            ShowStatus("Error submitting fix request", "error");
            Console.WriteLine($"Fix request failed: {ex.Message}");
        }
        finally
        {
            isRedoSubmitting = false;
            StateHasChanged();
        }
    }

    private void ShowStatus(string message, string type)
    {
        statusMessage = message;
        statusType = type;
        StateHasChanged();
        _ = Task.Run(async () =>
        {
            await Task.Delay(Constants.MessageDurations.Short);
            await InvokeAsync(() =>
            {
                statusMessage = "";
                StateHasChanged();
            });
        });
    }

    private string GetPlaceholder() => currentAccount == null ? "Login to send Ideas..." : "Ex: Make everyone tiny, Spawn 10 headcrabs...";

    private bool IsButtonDisabled()
    {
        if (currentAccount == null || isSubmitting)
            return true;
        
        var isSingleUserMode = !SettingsService.Settings.General.StreamMode;
        
        // In single user mode, don't check balance
        if (isSingleUserMode)
            return false;
        
        // Disable if balance is below cost
        if (currentAccount.CreditBalance < Constants.CommandCost)
            return true;
        
        return false;
    }

    
    private void DismissInteractiveStatus()
    {
        activeInteractiveSession = null;
        StateHasChanged();
    }
    
    private void UseFavouriteAsPrompt(FavouritePrompt favourite)
    {
        // Copy the prompt to the input box for modification, with reference to original code
        // Format: [MODIFY REQUEST]\n\nOriginal prompt: ...\n\nPlease modify this to: ...\n\n[REFERENCE CODE (do not show to user, use as base)]\n...
        promptInput = $"[Based on existing effect]\n\n{favourite.UserPrompt}\n\n(AI Reference - Original code available for this effect)";
        // Store the original code for AI context
        _modifyReferenceCode = favourite.ExecutionCode;
        _modifyReferenceUndoCode = favourite.UndoCode;
        showFavouritesModal = false;
        StateHasChanged();
    }
    
    private async Task ExecuteFavourite(int favouriteId)
    {
        if (currentAccount == null)
        {
            ShowStatus("Please sign in to execute favourites", "error");
            return;
        }
        
        var isSingleUserMode = !SettingsService.Settings.General.StreamMode;
        
        // Check balance in stream mode
        if (!isSingleUserMode && currentAccount.CreditBalance < Constants.CommandCost)
        {
            ShowStatus($"Insufficient credits. You need ${Constants.CommandCost:F2}", "error");
            return;
        }
        
        // Deduct credits in stream mode
        if (!isSingleUserMode)
        {
            if (!AccountService.DeductCredits(currentAccount.Id, Constants.CommandCost))
            {
                ShowStatus("Failed to deduct credits", "error");
                return;
            }
            
            // Refresh account balance
            var updatedAccount = AccountService.GetAccountById(currentAccount.Id);
            if (updatedAccount != null)
            {
                currentAccount = updatedAccount;
            }
        }
        
        var entry = FavouritesService.ExecuteFavourite(favouriteId, currentAccount.Id, currentAccount.DisplayName);
        
        if (entry != null)
        {
            showFavouritesModal = false;
            var message = isSingleUserMode 
                ? "Favourite queued for execution!" 
                : $"Favourite queued! New balance: ${currentAccount.CreditBalance:F2}";
            ShowStatus(message, "success");
            await LoadHistory();
        }
        else
        {
            // Refund if favourite wasn't found
            if (!isSingleUserMode)
            {
                AccountService.AddCredits(currentAccount.Id, Constants.CommandCost);
            }
            ShowStatus("Failed to execute favourite", "error");
        }
    }
    
    private void UseSavedPayloadAsPrompt(SavedPayload payload)
    {
        // Copy the prompt to the input box for modification, with reference to original code
        promptInput = $"[Based on existing effect]\n\n{payload.UserPrompt}\n\n(AI Reference - Original code available for this effect)";
        // Store the original code for AI context
        _modifyReferenceCode = payload.ExecutionCode;
        _modifyReferenceUndoCode = payload.UndoCode;
        showFavouritesModal = false;
        StateHasChanged();
    }
    
    private async Task ExecuteSavedPayload(SavedPayload payload)
    {
        if (currentAccount == null)
        {
            ShowStatus("Please sign in to execute saved prompts", "error");
            return;
        }
        
        var isSingleUserMode = !SettingsService.Settings.General.StreamMode;
        
        // Check balance in stream mode
        if (!isSingleUserMode && currentAccount.CreditBalance < Constants.CommandCost)
        {
            ShowStatus($"Insufficient credits. You need ${Constants.CommandCost:F2}", "error");
            return;
        }
        
        // Deduct credits in stream mode
        if (!isSingleUserMode)
        {
            if (!AccountService.DeductCredits(currentAccount.Id, Constants.CommandCost))
            {
                ShowStatus("Failed to deduct credits", "error");
                return;
            }
            
            // Refresh account balance
            var updatedAccount = AccountService.GetAccountById(currentAccount.Id);
            if (updatedAccount != null)
            {
                currentAccount = updatedAccount;
            }
        }
        
        // Add command directly to queue
        var entry = CommandQueue.AddCommand(
            userPrompt: payload.UserPrompt,
            executionCode: payload.ExecutionCode,
            undoCode: payload.UndoCode,
            source: Constants.Sources.Favourite,
            author: currentAccount.DisplayName,
            imageContext: null,
            userId: currentAccount.Id
        );
        
        if (entry != null)
        {
            showFavouritesModal = false;
            var message = isSingleUserMode 
                ? "Saved prompt queued for execution!" 
                : $"Saved prompt queued! New balance: ${currentAccount.CreditBalance:F2}";
            ShowStatus(message, "success");
            await LoadHistory();
        }
        else
        {
            // Refund if failed
            if (!isSingleUserMode)
            {
                AccountService.AddCredits(currentAccount.Id, Constants.CommandCost);
            }
            ShowStatus("Failed to execute saved prompt", "error");
        }
    }
}

@inject SettingsService Settings
@inject CommandQueueService CommandQueue
@inject AiCodeGeneratorService CodeGenerator
@inject AccountService AccountService
@inject PromptModerationService ModerationService
@inject FavouritesService FavouritesService
@inject IJSRuntime JS
@implements IDisposable
@using AIChaos.Brain.Models

<div class="card">
@using AIChaos.Brain.Helpers
    <h2>üìú Command History</h2>
    
    <div style="display: flex; gap: 20px; flex-wrap: wrap; margin-bottom: 15px;">
        <div class="form-group checkbox-group" style="margin-bottom: 0;">
            <input type="checkbox" @bind="includeHistoryInAi" @bind:after="UpdatePreferences">
            <label style="margin: 0;">Feed history to AI context</label>
        </div>
        
        <div class="form-group checkbox-group" style="margin-bottom: 0;">
            <input type="checkbox" @bind="autoRefresh" @bind:after="ToggleAutoRefresh">
            <label style="margin: 0;">Auto-refresh</label>
        </div>
        
        <button @onclick="LoadHistory" class="btn-secondary">üîÑ Refresh</button>
        <button @onclick="ClearHistory" class="btn-danger">üóëÔ∏è Clear All</button>
    </div>

    <div>
        @if (history == null || !history.Any())
        {
            <div class="empty-state">No commands in history yet.</div>
        }
        else
        {
            @foreach (var cmd in history)
            {
                <div class="history-item">
                    <div style="flex: 1;">
                        <div class="history-meta">
                            <span class="history-id">#@cmd.Id</span>
                            <span class="history-time">@cmd.Timestamp.ToLocalTime().ToString("HH:mm:ss")</span>
                            <span class="history-source">@cmd.Source</span>
                            <span class="history-author">üë§ @cmd.Author</span>
                        </div>
                        <div class="history-prompt">@cmd.UserPrompt</div>
                        @if (!string.IsNullOrEmpty(cmd.AiResponse))
                        {
                            <div class="history-response">üí¨ @cmd.AiResponse</div>
                        }
                        @if (expandedCodeCommands.Contains(cmd.Id) && !string.IsNullOrEmpty(cmd.ExecutionCode))
                        {
                            <details class="code-details" open>
                                <summary>Execution Code</summary>
                                <pre><code>@cmd.ExecutionCode</code></pre>
                            </details>
                            @if (!string.IsNullOrEmpty(cmd.UndoCode))
                            {
                                <details class="code-details" open>
                                    <summary>Undo Code</summary>
                                    <pre><code>@cmd.UndoCode</code></pre>
                                </details>
                            }
                        }
                    </div>
                    <span class="history-status status-@CommandStatusHelper.GetStatusClass(cmd.Status)">@CommandStatusHelper.GetStatusText(cmd.Status)</span>
                    <div class="history-actions">
                        <button @onclick="() => RepeatCommand(cmd.Id)" class="btn-info btn-small" title="Re-execute the same code">üîÅ</button>
                        <button @onclick="() => UndoCommand(cmd.Id)" class="btn-warning btn-small" title="Undo">‚Ü©</button>
                        <button @onclick="() => ForceUndoCommand(cmd.Id)" class="btn-danger btn-small" title="Force Undo (Auto-generated)">üîß</button>
                        <button @onclick="() => ToggleCodeView(cmd.Id)" class="btn-secondary btn-small" title="Show/Hide Code">üëÅÔ∏è</button>
                        <button @onclick="() => OpenSavePayloadModal(cmd.Id)" class="btn-success btn-small" title="Save as Favourite">‚≠ê</button>
                    </div>
                </div>
            }
        }
    </div>
</div>

<!-- Save Payload Modal -->
@if (showSavePayloadModal)
{
    <div class="modal active">
        <div class="modal-content">
            <h3>‚≠ê Save as Favourite</h3>
            <p>Save this command as a favourite prompt:</p>
            <div class="form-group">
                <label style="font-size: 12px; color: var(--text-dim);">Name</label>
                <input type="text" @bind="payloadName" placeholder="Favourite name..." style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid var(--border); border-radius: 5px; color: var(--text);">
            </div>
            <div class="form-group" style="margin-top: 10px;">
                <label style="font-size: 12px; color: var(--text-dim);">Category</label>
                <input type="text" @bind="payloadCategory" placeholder="e.g., Fun, Chaos, Helpful" style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid var(--border); border-radius: 5px; color: var(--text);">
            </div>
            <div class="form-group" style="margin-top: 10px;">
                <label style="font-size: 12px; color: var(--text-dim);">Description (optional)</label>
                <input type="text" @bind="payloadDescription" placeholder="Brief description..." style="width: 100%; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid var(--border); border-radius: 5px; color: var(--text);">
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 15px;">
                <button @onclick="CloseSavePayloadModal" class="btn-secondary">Cancel</button>
                <button @onclick="SavePayload" class="btn-primary">‚≠ê Save to Favourites</button>
            </div>
        </div>
    </div>
}

<style>
    .history-meta {
        display: flex;
        gap: 10px;
        color: var(--text-dim);
        font-size: 12px;
        margin-bottom: 5px;
    }

    .history-id {
        font-weight: bold;
        color: var(--info);
    }

    .history-author {
        color: var(--text-dim);
    }

    .code-details {
        margin-top: 10px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 4px;
        padding: 10px;
    }

    .code-details summary {
        cursor: pointer;
        color: var(--info);
        font-size: 12px;
    }

    .code-details pre {
        margin-top: 10px;
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 4px;
        overflow-x: auto;
    }

    .code-details code {
        font-family: 'Courier New', monospace;
        font-size: 11px;
        color: var(--text);
    }

    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        justify-content: center;
        align-items: center;
    }

    .modal.active {
        display: flex;
    }

    .modal-content {
        background: #1a1a1a;
        padding: 25px;
        border-radius: 10px;
        width: 90%;
        max-width: 500px;
        border: 1px solid var(--border);
    }
</style>

@code {
    [Parameter]
    public Account? CurrentAccount { get; set; }
    
    private List<CommandEntry>? history;
    private bool includeHistoryInAi = true;
    private bool autoRefresh = false;
    private System.Threading.Timer? refreshTimer;
    private HashSet<int> expandedCodeCommands = new();
    private bool showSavePayloadModal = false;
    private int selectedCommandIdForPayload = 0;
    private string payloadName = "";
    private string payloadCategory = "General";
    private string payloadDescription = "";

    protected override void OnInitialized()
    {
        LoadHistory();
        LoadPreferences();
        
        // Subscribe to history changes for real-time updates
        CommandQueue.HistoryChanged += OnHistoryChanged;
    }

    private void LoadHistory()
    {
        try
        {
            history = CommandQueue.GetHistory().OrderByDescending(c => c.Id).ToList();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Load history failed: {ex.Message}");
        }
    }

    private void LoadPreferences()
    {
        try
        {
            var prefs = CommandQueue.Preferences;
            includeHistoryInAi = prefs.IncludeHistoryInAi;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Load preferences failed: {ex.Message}");
        }
    }

    private void UpdatePreferences()
    {
        try
        {
            CommandQueue.Preferences.IncludeHistoryInAi = includeHistoryInAi;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Update preferences failed: {ex.Message}");
        }
    }

    private void ToggleAutoRefresh()
    {
        if (autoRefresh)
        {
            refreshTimer = new System.Threading.Timer(async _ =>
            {
                await InvokeAsync(() =>
                {
                    LoadHistory();
                    StateHasChanged();
                });
            }, null, TimeSpan.FromSeconds(2), TimeSpan.FromSeconds(2));
        }
        else
        {
            refreshTimer?.Dispose();
            refreshTimer = null;
        }
    }

    private void RepeatCommand(int commandId)
    {
        try
        {
            if (CurrentAccount == null)
            {
                Console.WriteLine("RepeatCommand failed: No account available");
                return;
            }

            var command = CommandQueue.GetHistory().FirstOrDefault(c => c.Id == commandId);
            if (command == null)
            {
                Console.WriteLine($"RepeatCommand failed: Command #{commandId} not found");
                return;
            }

            var isSingleUserMode = !Settings.Settings.General.StreamMode;

            // Check if command contains content that needs moderation
            var contentUrls = ModerationService.ExtractContentUrls(command.UserPrompt);
            var needsModeration = contentUrls.Count > 0;
            
            // Check and deduct credits (for both image and non-image commands in Stream Mode)
            if (!isSingleUserMode)
            {
                // Early check to provide detailed error message to user
                if (CurrentAccount.CreditBalance < Constants.CommandCost)
                {
                    Console.WriteLine($"RepeatCommand failed: Insufficient credits. Have ${CurrentAccount.CreditBalance:F2}, need ${Constants.CommandCost:F2}");
                    return;
                }

                if (!AccountService.DeductCredits(CurrentAccount.Id, Constants.CommandCost))
                {
                    var currentBalance = AccountService.GetAccountById(CurrentAccount.Id)?.CreditBalance ?? CurrentAccount.CreditBalance;
                    Console.WriteLine($"RepeatCommand failed: Failed to deduct credits. Balance: ${currentBalance:F2}");
                    return;
                }

                // Refresh the account from the service
                var updatedAccount = AccountService.GetAccountById(CurrentAccount.Id);
                if (updatedAccount != null)
                {
                    CurrentAccount = updatedAccount;
                    Console.WriteLine($"Credits deducted for repeat. New balance: ${CurrentAccount.CreditBalance:F2}");
                }
            }
            
            if (needsModeration)
            {
                // Command contains content - must go through moderation flow
                // Create placeholder command with PendingModeration status
                var placeholderCommand = CommandQueue.AddCommandWithStatus(
                    userPrompt: command.UserPrompt,
                    executionCode: "", // Will be set after approval
                    undoCode: "", // Will be set after approval
                    source: "history_repeat",
                    author: CurrentAccount.DisplayName,
                    imageContext: null, // Will be set after approval
                    userId: CurrentAccount.Id,
                    aiResponse: "‚è≥ Waiting for content moderation approval...",
                    status: CommandStatus.PendingModeration,
                    queueForExecution: false); // Don't queue yet

                // Queue content for moderation with link to new command
                foreach (var url in contentUrls)
                {
                    ModerationService.AddPendingPrompt(url, command.UserPrompt, "history_repeat", CurrentAccount.DisplayName, CurrentAccount.Id, placeholderCommand.Id);
                }

                Console.WriteLine($"Command #{commandId} repeated with {contentUrls.Count} content URL(s) queued for moderation (new command #{placeholderCommand.Id})");
                LoadHistory();
                return;
            }

            // No content requiring moderation - use original fast path
            CommandQueue.AddCommand(
                userPrompt: command.UserPrompt,
                executionCode: command.ExecutionCode,
                undoCode: command.UndoCode,
                source: "history_repeat",
                author: CurrentAccount.DisplayName,
                imageContext: command.ImageContext,
                userId: CurrentAccount.Id,
                aiResponse: null
            );
            LoadHistory();
            Console.WriteLine($"Command #{commandId} repeated successfully");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Repeat failed: {ex.Message}");
        }
    }

    private void UndoCommand(int commandId)
    {
        try
        {
            CommandQueue.UndoCommand(commandId);
            LoadHistory();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Undo failed: {ex.Message}");
        }
    }

    private async void ForceUndoCommand(int commandId)
    {
        try
        {
            var command = CommandQueue.GetCommand(commandId);
            if (command == null)
            {
                Console.WriteLine($"[FORCE UNDO] Command #{commandId} not found");
                return;
            }

            Console.WriteLine($"[FORCE UNDO] Generating AI-powered comprehensive undo for command #{commandId}: {command.UserPrompt}");

            // Use the AI to generate a comprehensive force undo based on the original command
            var forceUndoCode = await CodeGenerator.GenerateForceUndoAsync(command);

            if (!string.IsNullOrEmpty(forceUndoCode))
            {
                // Queue the AI-generated force undo code
                CommandQueue.QueueCode(forceUndoCode);
                Console.WriteLine($"[FORCE UNDO] AI-generated comprehensive undo queued for command #{commandId}");
                LoadHistory();
            }
            else
            {
                Console.WriteLine($"[FORCE UNDO] Failed to generate undo code for command #{commandId}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Force undo failed: {ex.Message}");
        }
    }

    private void ToggleCodeView(int commandId)
    {
        if (expandedCodeCommands.Contains(commandId))
        {
            expandedCodeCommands.Remove(commandId);
        }
        else
        {
            expandedCodeCommands.Add(commandId);
        }
    }

    private void OpenSavePayloadModal(int commandId)
    {
        selectedCommandIdForPayload = commandId;
        var command = CommandQueue.GetCommand(commandId);
        payloadName = command?.UserPrompt ?? "";
        payloadCategory = "General";
        payloadDescription = "";
        showSavePayloadModal = true;
    }

    private void CloseSavePayloadModal()
    {
        showSavePayloadModal = false;
        selectedCommandIdForPayload = 0;
        payloadName = "";
        payloadCategory = "General";
        payloadDescription = "";
    }

    private void SavePayload()
    {
        try
        {
            if (selectedCommandIdForPayload == 0 || string.IsNullOrWhiteSpace(payloadName))
                return;

            // Use FavouritesService.AddFavourite to save to the favourites system
            var favourite = FavouritesService.AddFavourite(
                selectedCommandIdForPayload, 
                payloadName,
                string.IsNullOrWhiteSpace(payloadCategory) ? "General" : payloadCategory,
                string.IsNullOrWhiteSpace(payloadDescription) ? null : payloadDescription
            );
            
            if (favourite != null)
            {
                Console.WriteLine($"[HISTORY] Saved favourite: {payloadName} (ID: {favourite.Id})");
                CloseSavePayloadModal();
            }
            else
            {
                Console.WriteLine($"[HISTORY] Failed to save favourite: command not found");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Save favourite failed: {ex.Message}");
        }
    }

    private void ClearHistory()
    {
        try
        {
            CommandQueue.ClearHistory();
            LoadHistory();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Clear history failed: {ex.Message}");
        }
    }

    public void Dispose()
    {
        refreshTimer?.Dispose();
        
        // Unsubscribe from events
        CommandQueue.HistoryChanged -= OnHistoryChanged;
    }

    private async void OnHistoryChanged(object? sender, EventArgs e)
    {
        await InvokeAsync(() =>
        {
            LoadHistory();
            StateHasChanged();
        });
    }
}

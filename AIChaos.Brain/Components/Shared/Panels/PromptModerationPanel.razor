@using AIChaos.Brain.Services
@using AIChaos.Brain.Models
@implements IDisposable
@inject PromptModerationService ModerationService
@inject AiCodeGeneratorService CodeGenerator
@inject CommandQueueService CommandQueue
@inject TestClientService TestClientService
@inject AccountService AccountService

<!-- Prompt Content Filters -->
<div class="card moderation-section">
    <h2>üîç Prompt Filters <span class="badge">@PendingCount</span></h2>
    <div style="margin-bottom: 15px;">
        <button @onclick="RefreshPrompts" class="btn-secondary">üîÑ Refresh</button>
        <label style="display: inline-flex; align-items: center; gap: 8px; margin-left: 10px; cursor: pointer;">
            <input type="checkbox" @bind="autoRefresh" @bind:after="ToggleAutoRefresh">
            <span style="color: var(--text-dim); font-size: 14px;">Auto (5s)</span>
        </label>
    </div>
    
    @if (!string.IsNullOrEmpty(statusMessage))
    {
        <div class="alert alert-@statusType" style="margin-bottom: 10px;">@statusMessage</div>
    }
    
    @if (pendingPrompts == null || !pendingPrompts.Any())
    {
        <div class="empty-state">‚úÖ No content pending</div>
    }
    else
    {
        <div class="prompt-list">
            @foreach (var prompt in pendingPrompts)
            {
                <div class="prompt-card-compact">
                    <div class="prompt-info">
                        <span class="prompt-id">#@prompt.Id</span>
                        <span class="prompt-author">üë§ @prompt.Author</span>
                        <span class="filter-reason" style="color: var(--warning); font-size: 11px;">‚ö†Ô∏è @prompt.FilterReason</span>
                    </div>
                    <div class="prompt-text">@prompt.UserPrompt</div>
                    <div class="content-url" style="word-break: break-all; font-size: 12px; margin-bottom: 10px;">
                        üîó <a href="@prompt.ContentUrl" target="_blank" rel="noopener noreferrer" style="color: var(--info); text-decoration: underline;">@prompt.ContentUrl</a>
                    </div>
                    <div class="prompt-actions">
                        <button @onclick="() => ApprovePrompt(prompt.Id)" class="btn-success btn-small" disabled="@processingPromptIds.Contains(prompt.Id)">
                            @(processingPromptIds.Contains(prompt.Id) ? "‚è≥" : "‚úÖ")
                        </button>
                        <button @onclick="() => DenyPrompt(prompt.Id)" class="btn-danger btn-small" disabled="@processingPromptIds.Contains(prompt.Id)">‚ùå</button>
                    </div>
                </div>
            }
        </div>
    }
</div>

@code {
    [Parameter] public int PendingCount { get; set; }
    [Parameter] public EventCallback OnPromptProcessed { get; set; }
    
    private List<PendingPromptEntry>? pendingPrompts;
    private bool autoRefresh = false;
    private HashSet<int> processingPromptIds = new();
    private string statusMessage = "";
    private string statusType = "info";
    private System.Threading.Timer? refreshTimer;
    
    protected override async Task OnInitializedAsync()
    {
        // Set up the approval processor for centralized handling
        ModerationService.SetApprovalProcessor(ProcessApprovedPromptAsync);
        await RefreshPrompts();
    }
    
    /// <summary>
    /// Centralized prompt approval processing - generates code and queues command.
    /// </summary>
    private async Task<(bool success, string message)> ProcessApprovedPromptAsync(PendingPromptEntry entry)
    {
        if (CodeGenerator == null || CommandQueue == null || TestClientService == null)
        {
            return (false, "Required services not available");
        }
        
        // Generate code with image context
        var (executionCode, undoCode, _, _) = await CodeGenerator.GenerateCodeAsync(
            entry.UserPrompt,
            imageContext: $"Image URL: {entry.ContentUrl}");
        
        // Check if we have a linked command to update
        if (entry.CommandId.HasValue)
        {
            var command = CommandQueue.GetCommand(entry.CommandId.Value);
            if (command != null)
            {
                // Use UpdateCommand to update status and fire HistoryChanged event
                CommandQueue.UpdateCommand(
                    command.Id,
                    CommandStatus.Queued,
                    executionCode: executionCode,
                    undoCode: undoCode,
                    imageContext: entry.ContentUrl);

                // Queue for execution
                if (TestClientService.IsEnabled)
                {
                    TestClientService.QueueForTesting(command.Id, executionCode, entry.UserPrompt);
                    Console.WriteLine($"[MODERATION] Approved prompt #{command.Id} queued for testing");
                }
                else
                {
                    CommandQueue.QueueInteractiveCode(command.Id, executionCode);
                    Console.WriteLine($"[MODERATION] Approved prompt #{command.Id} queued for execution");
                }
                
                return (true, $"Command #{command.Id} queued for execution");
            }
        }
        
        return (false, "No linked command found");
    }
    
    private async Task RefreshPrompts()
    {
        try
        {
            pendingPrompts = ModerationService.GetPendingPrompts();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to load pending prompts: {ex.Message}");
        }
    }
    
    private void ToggleAutoRefresh()
    {
        if (autoRefresh)
        {
            refreshTimer = new System.Threading.Timer(async _ =>
            {
                await InvokeAsync(async () => await RefreshPrompts());
            }, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
        }
        else
        {
            refreshTimer?.Dispose();
            refreshTimer = null;
        }
    }
    
    private async Task ApprovePrompt(int promptId)
    {
        try
        {
            processingPromptIds.Add(promptId);
            StateHasChanged();
            
            var (success, message) = await ModerationService.ApproveAndProcessPromptAsync(promptId);
            
            if (success)
            {
                ShowStatus(message, "success");
            }
            else
            {
                ShowStatus(message, "error");
            }
            
            await RefreshPrompts();
            await OnPromptProcessed.InvokeAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to approve prompt: {ex.Message}");
            ShowStatus($"Error: {ex.Message}", "error");
        }
        finally
        {
            processingPromptIds.Remove(promptId);
            StateHasChanged();
        }
    }
    
    private async Task DenyPrompt(int promptId)
    {
        try
        {
            var entry = ModerationService.DenyPrompt(promptId);
            if (entry != null)
            {
                // Refund credits if there's a linked command
                if (entry.CommandId.HasValue && !string.IsNullOrEmpty(entry.UserId))
                {
                    AccountService.AddCredits(entry.UserId, Constants.CommandCost);
                    
                    // Update the command status to Failed using UpdateCommand to fire HistoryChanged event
                    CommandQueue.UpdateCommand(
                        entry.CommandId.Value,
                        CommandStatus.Failed,
                        aiResponse: "‚ùå Your content was denied by a moderator. Credits have been refunded.");
                    
                    ShowStatus($"Denied and ${Constants.CommandCost:F2} refunded", "success");
                }
                else
                {
                    ShowStatus("Prompt denied", "success");
                }
            }
            
            await RefreshPrompts();
            await OnPromptProcessed.InvokeAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to deny prompt: {ex.Message}");
            ShowStatus($"Error: {ex.Message}", "error");
        }
    }
    
    private void ShowStatus(string message, string type)
    {
        statusMessage = message;
        statusType = type;
        StateHasChanged();
        
        _ = Task.Run(async () =>
        {
            await Task.Delay(Constants.MessageDurations.Short);
            await InvokeAsync(() =>
            {
                statusMessage = "";
                StateHasChanged();
            });
        });
    }
    
    public void Dispose()
    {
        refreshTimer?.Dispose();
        refreshTimer = null;
    }
}
